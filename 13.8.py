# if some_var is None:
#     print("NoneType")
# else:
#     print(type(some_var))

# some_var = (2,)
# print(type(some_var))

# a = '' # пустая строка
# b = a or 1
# print(b)

# print(42 and 0 and '' and False)

# a = "foo"
# b = "bar"
# print(1 and a or b)

# a = ""
# b = "bar"
# print(1 and a or b)

# Задание 13.8.6-13.8.8
# пусть a и b - переменные, которые мы хотим проверить
# if a and b:
#     print("Обе переменные истинные")
#     print(a,b)
# elif a or b:
#     print("Одна из переменных истинная")
#     print(a or b) # печать одной переменной, той, которая является истинной
# else:
#     print("Обе переменные ложные")

# Задание 13.8.9-13.8.10
# a = int(input())
# 1й вариант
# if 100 <= a <= 999:
#     if a % 2 == 0:
#         if a % 3 == 0:
#             print('число удовлетворяет условиям')

# 2й вариант
# if type(a) == int and 100 <= a <= 999 and a % 2 == 0 and a % 3 == 0:
#     print("Число удовлетворяет условиям")

# 3й вариант
# if all([type(a) == int,
#         100 <= a <= 999,
#         a % 2 == 0,
#         a % 3 == 0]):
#     print("Число удовлетворяет условиям")

# Задание 13.8.11
# Напишите программу, которая на вход принимает последовательность целых чисел, и возвращает True, если все числа
# ненулевые, и False, если хотя бы одно число равно 0.
# L = list(map(int, input().split()))

# print(all(L))

# Задание 13.8.12
# L = list(map(int, input().split()))
# print(not any(L))

# squares = [i**2 for i in range(1,11)] #генератор списков, квадрат чисел
# squares = [i**2 for i in range(1,11) if i % 2 == 1] #генератор списков, квадрат нечетных чисел
# list_tuples = [(i, i**2) for i in range(1,11)] #генератор списков, кортеж
# M = [[i+j for j in range(5)] for i in range(5)] #генератор списков, матрица
# print(M)

# Задание 13.8.13
# При помощи генератора списков создайте таблицу умножения чисел от 1 до 10

# T = [[i*j for j in range(1,11)] for i in range(1,11)]
# print(T)

# Задание 13.8.14 Модифицируйте последний пример таким образом, чтобы в список сохранялось True, если элемент четный,
# # и False, если элемент нечетный.
# L = [int(input()) % 2 == 0 for i in range(5)]
# print(L)

# Задание 13.8.15. Напишите программу таким образом, чтобы выводилось True, если есть хотя бы одно четное число.
# L = [int(input()) % 2 == 0 for i in range(5)]
# print(any([L]))

# Задание 13.8.16.Подумайте, как нужно записать логическое выражение, используя all([ ]) и any([ ]) над списком
# четности, если его результат будет истинным тогда и только тогда, когда в списке есть хотя бы один четный и хотя бы
# один нечетный элемент.
# L = [int(input()) % 2 == 0 for i in range(5)]
# print(any(L) and not all(L))

# Функция ZIP - озволяет объединить два списка в новый список кортежей, каждый из которых будет содержать по одному
# элементу из каждого списка
# L = [i for i in range(10)]
# M = [i for i in range(10,0,-1)]
# print(L)
# print(M)
# # умножаем умножаем элементы списков друг на друга, по порядку (индексам).
#  N = [ ]
#
#  for i in range(10):
#     N.append(L[i] * M[i])
#     print(N)
#Полученный рез-тат будет правильным. но не по питоновски, надо упростить.
# применим функцию ZIP
# for a in zip(L,M):
#     print(a)
# или
# for a, b in zip(L,M):
#     print('a =', a, 'b =', b)

# Задание 13.8.17 Используя функцию zip() внутри генераторов списков, вычислите поэлементные произведения списков L и M.
# L = [i for i in range(10)]
# M = [i for i in range(10,0,-1)]
# print(L)
# print(M)
# N = [a*b for a,b in zip(L,M)]
# print(N)

# Задание 13.8.18 Реализуйте программу, которая сжимает последовательность символов. На вход подается последовательность
# вида aaabbccccdaa. Необходимо вывести строку, состоящую из символов и количества повторений этого символа. Вывод
# должен выглядеть как: a3b2c4d1a2
text = input('введите последовательность: ')  # получаем строку

first = text[0]  # сохраняем первый символ
count = 0  # заводим счетчик
result = ''  # и результирующую строку

for c in text:
    if c == first:  # если символ совпадает с сохраненным,
        count += 1  # то увеличиваем счетчик
    else:
        result += first + str(count)  # иначе - записываем в результат
        first = c  # и обновляем сохраненный символ с его счетчиком
        count = 1

result += first + str(count)  # и добавляем в результат последний символ
print(result)